# Report.md  
Практическая работа №4 — Мокирование внешних зависимостей  
Вариант 1: Платёжный шлюз (HTTP API)

---

# 1. Стратегия мокирования

Основная идея — полностью изолировать сервис `PaymentService`  
от реального HTTP-API, чтобы тесты были:

- быстрыми  
- предсказуемыми  
- не зависели от сети  
- не зависели от sandbox внешних API

Используется `unittest.mock.patch` для подмены функции `requests.post`.

---

# 2. Какие зависимости были замокированы и почему

| Замокированный компонент | Причина |
|-------------------------|---------|
| `requests.post`         | Изоляция от реального HTTP API |
| Ответ API (`response.json()`) | Контроль содержимого, моделирование разных статусов |
| `raise_for_status()`    | Проверка поведения при ошибках 400/500 |
| Исключения Timeout / ConnectionError | Тестирование негативных сценариев |

---

# 3. Плюсы мокирования

- Высокая скорость выполнения тестов  
- Полная изоляция от внешних сервисов  
- Тесты предсказуемы и повторяемы  
- Лёгко проверять, что запрос отправлен корректно

---

# 4. Минусы мокирования

- Нет гарантии, что реальный API работает так же  
- Возможны «зелёные, но бесполезные» тесты  
- Можно случайно замокировать слишком много и потерять связь с реальностью  
- Не покрываются проблемы инфраструктуры

---

# 5. Альтернативы мокам

### TestContainers
Запуск real-service в docker.  
+ максимально реалистично  
– более медленно

### In-memory фейковые реализации  
Если API можно эмулировать на localhost.

### Stub-server (MockWebServer, WireMock)  
Запускает локальный HTTP-сервер с фиксированными ответами.

---

# 6. Контрольные вопросы

### 1. Разница между mock и stub  
**Stub** — возвращает заранее зашитые данные  
**Mock** — также проверяет *как* был вызван (параметры, количество вызовов)

Пример:  
- Stub: `response.json.return_value = {...}`  
- Mock: `mock_post.assert_called_once_with(...)`

---

### 2. Может ли избыточное мокирование привести к бесполезным тестам?  
Да.  
Если замокировать внутренние детали реализации, тесты будут зелёные,  
но любое изменение кода будет ломать их без причины -> тесты становятся «хрупкими».

---

### 3. Как проверить, что мок вызван с нужными параметрами?  

```python
mock_post.assert_called_once()
args, kwargs = mock_post.call_args
assert kwargs["json"]["amount"] == 150
```

### 4. Как избежать «хрупкости» тестов при мокировании?  
- мокировать только внешние зависимости  
- не мокировать внутренние методы объекта  
- тестировать поведение, а не реализацию  
- использовать assert только для внешних эффектов